---
external: false
title: "关于我作为初级前端时遇到的坑"
date: 2022-11-02
---


### 1.vuerouter Uncaught (in promise)

这个是在用 vue-router 进行跳转时,重复点击了元素两次,控制台会报错,据翻看大佬的解释，vue-router ≥3.0 版本回调形式以及改成 promise api 的形式了，返回的是一个 promise，如果没有捕获到错误，控制台始终会出现如图的警告，针对于路由跳转相同的地址，目前的解决方案:

```javascript
this.$router.push('/location').catch((err) => {
  console.log(err)
})
```

> 大佬说是在 main.js 文件下加入如下代码：

```javascript
import Router from 'vue-router'
const originalPush = Router.prototype.push
Router.prototype.push = function push(location) {
  return originalPush.call(this, location).catch((err) => err)
}
```

结果：加入后亲测有效，确实不再提示这个错误了

### 2.css 设置多行溢出

```css
单行溢出
overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;
```

```css
多行溢出
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;
```

## 3.刷新的方法:

```
//用的是reload方法
window.location.reload()
//这种方法不好的方式是会刷新空白,用户体验很不好
```

## 4.css 鼠标 🈲 用

```css
pointer-events: none;
cursor: default;
opacity: 1; //设置透明度
```

## 5,get 方法与 post 方法区别

#### http

超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。

#### http 方法：

HEAD: 与 GET 相同，但只返回 HTTP 报头，不返回文档主体 PUT: 上传指定的 URI 表示 DELETE: 删除指定资源 OPTIONS: 返回服务器支持的 HTTP 方法 CONNECT: 把请求连接转换到透明的 TCP/IP 通道 POST: 向指定的资源提交要被处理的数据

```
// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
复制代码
```

GET: 从指定的资源请求数据

#### GET 和 POST 的区别

1. GET 请求可被缓存
1. GET 请求保留在浏览器历史记录中
1. GET 请求可被收藏为书签
1. GET 请求不应在处理敏感数据时使用
1. GET 请求有长度限制(2048 字符),IE 和 Safari 浏览器限制 2k;Opera 限制 4k;Firefox，Chrome 限制 8k
1. GET 请求只应当用于取回数据

1. POST 请求不会被缓存
1. POST 请求不会保留在浏览器历史记录中
1. POST 不能被收藏为书签
1. POST 请求对数据长度没有要求

## 6.js 求平面两点之间的距离

```javascript
// 数据可以以数组方式存储，也可以是对象方式
let a = { x: '6', y: 10 },
  b = { x: 8, y: 20 }
function distant(a, b) {
  let dx = Number(a.x) - Number(b.x)
  let dy = Number(a.y) - Number(b.y)
  return Math.pow(dx * dx + dy * dy, 0.5)
}
```

## 7.css 禁止用户选择 👆

```css
body {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
```

## 8.for in 与 for of 方法

```javascript
let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2)
function find(arr) {
  for (let num of arr) {
    console.log(num)
  }
}
find(arr)
//for of中的num是完整的arr数组中的值
let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2)
function find(arr) {
  for (let num in arr) {
    console.log(num)
  }
}
find(arr)
//但是for in 中的num相当于下标,只有输出arr[num]才能获得数组中的值
```

## 9.数组去重

```javascript
//indexOf()方法
let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2)
    function find(arr) {
        let res = []
        for (let num of arr) {
            if (res.indexOf(num) === -1) {
                res.push(num)
            }
        }
        return res
    }
    console.log(find(arr))\
    //1,2,3,5,6
```

## 10.如何提高首频加载速度

> 1.js 外联文件放到 body 底部，css 外联文件放到 head 内
> 2.http 静态资源尽量用多个子域名 3.服务器端提供 html 和 http 静态资源时最好开启 gzip 4.在 js,css,img 等资源响应的 http headers 里设置 expires,last-modified 5.尽量减少 http requests 的数量
> 6.js/css/html/img 资源压缩 7.使用 css spirtes，可以减少 img 请求次数 8.大图使用 lazyload 懒加载 9.避免 404，减少外联 js 10.减少 cookie 大小可以提高获得响应的时间 11.减少 dom elements 的数量 12.使用异步脚本，动态创建脚本

## 11.简述一下你对 HTML 语义化的理解

用正确的标签做正确的事情。 html 语义化让页面的内容结构化，便于对浏览器、搜索引擎解析; 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

## 12.请描述一下 cookies，sessionStorage 和 localStorage 的区别

cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭

## 13.css overflow 属性

overflow 属性规定当内容溢出元素框时发生的事情。

> 这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。

值:

| visible | 默认值。内容不会被修剪，会呈现在元素框之外。             |
| ------- | -------------------------------------------------------- |
| hidden  | 内容会被修剪，并且其余内容是不可见的。                   |
| scroll  | 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 |
| auto    | 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 |
| inherit | 规定应该从父元素继承 overflow 属性的值。                 |

## 让 overflow:scroll 平滑滚动

```javascript
-webkit-overflow-scrolling: touch;
```

## 14.position 中的 relative 和 absolute 的定位原点问题

absolute 生成绝对定位的元素，相对于值不为 static 的第一个父元素进行定位。 fixed （老 IE 不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值

## 15.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧 ？

- png24 位的图片在 iE6 浏览器上出现背景，解决方案是做成 PNG8.
- 浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的\*{margin:0;padding:0;}来统一。
- IE6 双边距 bug:块属性标签 float 后，又有横行的 margin 情况下，在 ie6 显示 margin 比设置的大。 浮动 ie 产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下 IE 会产生 20px 的距离，解决方案是在 float 的标签样式控制中加入 ——*display:inline;将其转化为行内属性。(*这个符号只有 ie6 会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将 IE 游览器从所有情况中分离出来。 接着，再次使用“+”将 IE8 和 IE7、IE6 分离开来，这样 IE8 已经独立识别。 css .bb{ background-color:red;/_所有识别_/ background-color:#00deff\9; /_IE6、7、8 识别_/ +background-color:#a200ff;/_IE6、7 识别_/ _background-color:#1e0bd1;/\_IE6 识别_/ }
- IE 下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用 getAttribute()获取自定义属性; Firefox 下,只能使用 getAttribute()获取自定义属性。 解决方法:统一通过 getAttribute()获取自定义属性。
- IE 下,even 对象有 x,y 属性,但是没有 pageX,pageY 属性; Firefox 下,event 对象有 pageX,pageY 属性,但是没有 x,y 属性。
- 解决方法：（条件注释）缺点是在 IE 浏览器下可能会增加额外的 HTTP 请求数。
- Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。
- 超链接访问过后 hover 样式就不出现了 被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}

## 16.css 优化,提高性能

关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp 对 css 进行语法检查、自动补前缀、打包压缩、自动优雅降级）；

## 17.让页面里的字体变清晰，变细用 CSS 怎么做

```javascript
-webkit-font-smoothing: antialiased;
```

## 18.This 对象的理解

> this 总是指向函数的直接调用者（而非间接调用者）； 如果有 new 关键字，this 指向 new 出来的那个对象； 在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 Window；

## 19.什么是 window 对象? 什么是 document 对象

> window 对象是指浏览器打开的窗口。 document 对象是 Documentd 对象（HTML 文档对象）的一个只读引用，window 对象的一个属性。

## 20.什么是闭包（closure），为什么要用它？

> 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部

## 21.如何判断一个对象谁否属于某个类

```javascript
if (a instanceof Person) {
  alert('yes')
}
//instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

// 判断对象类型最好的方式
// 对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。
//而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。
Object.prototype.toString.call('') // [object String]
Object.prototype.toString.call(1) // [object Number]
Object.prototype.toString.call(true) // [object Boolean]
Object.prototype.toString.call(Symbol()) //[object Symbol]
Object.prototype.toString.call(undefined) // [object Undefined]
Object.prototype.toString.call(null) // [object Null]
Object.prototype.toString.call(new Function()) // [object Function]
Object.prototype.toString.call(new Date()) // [object Date]
Object.prototype.toString.call([]) // [object Array]
Object.prototype.toString.call(new RegExp()) // [object RegExp]
Object.prototype.toString.call(new Error()) // [object Error]
Object.prototype.toString.call(document) // [object HTMLDocument]
Object.prototype.toString.call(window) //[object global] window 是全局对象 global 的引用
```

## 22.new 一个对象的过程

1、创建一个空对象，并且 **this** 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 **this** 引用的对象中。 3、新创建的对象由 **this** 所引用，并且最后隐式的返回 **this** 。

## 23.在 Vue 中的遍历方法 v-for 控制循环次数的方法

**1.截取循环的数据**     v-for="(item,index) in domainList.slice(0, 2)"      用这样的方法可以截取循环的数据长度，从而控制循环的次数 **2.通过 v-if 来控制**      v-for="(item,index) in domainList" v-if="index<3"      在标签下紧跟 v-if 来进行控制，这里是用索引来进行控制的，所以循环的时候记得把 index 这个参数加到 v-for 循环中。

## 24.箭头函数

对于箭头函数，`this`  关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。

## 25.获取接口数据的定义的数组

```javascript
 list: {
        course: {
          public_assesses: [],
          course_contents: [],
          public_collects: [],
          introduction: ''
        }
      },
```

在获取数据时，由于接口返回的数据嵌套过多，导致页面渲染报错，在定义数组保存接口数据时，可以定义好要接受的数据的“模版”，或者说把要使用的数据拿出来单独赋值

## 26.vue-router 跳转页面时传参成功但是页面没有刷新

```javascript
watch: {
    '$route' (to, from) {
      this.$router.go(0)
    }
  },
```

用 watch 监听 router 属性是否有变化，然后决定是否重新刷新页面

## 27.设置默认显示的子路由

```javascript
path: '/',
  component: () =>
      import('@/views/home_page/index'),
  name: 'home_page',
  redirect: 'index_cntent',//用redirect指出默认显示的子路由
  children: [{
    path: '/about_menu',
    component: () =>
          import('@/views/menu/about_menu'),
    name: 'about_menu'
  },
  {
    path: '/dervice_menu',
    component: () =>
          import('@/views/menu/dervice_menu'),
    name: 'dervice_menu'
  },
  {
    path: '/product_menu',
    component: () =>
          import('@/views/menu/product_menu'),
    name: 'product_menu'
  },
  {
    path: '/service_menu',
    component: () =>
          import('@/views/menu/service_menu'),
    name: 'service_menu'
  },
  {
    path: '/index_cntent',
    component: () =>
          import('@/views/menu/content'),
    name: 'index_cntent'
  }
  ]
},
```

## 28 关于 vue warn 的警告解决

一般出现 vue warn 的时候一般是 vue 数据渲染出错，绑定的某个值可能赋值出错，像是给了 undefined，或者是原本是图片地址却给了个字符串之类错误，往往导致这方面的错误的时候，提示里一般没有相关文件具体到哪一行那个语法出错，但是会提示了是那个文件，去文件里面逐一排查就好

## 29.最简单的方式实现前端下载功能（window.location）

用`window.locatio.href=“xxxx?”+（其他字段）+'&(其他字段)'`的方式可以实现打开新的窗口下载文件，前提是后端给返回文件的下载地址，默认打开地址的话像是图片会直接预览

## 30.textarea 禁止拖动,固定宽高

```
resize: none;
```

## 31.控制 v-for 循环的次数

```javascript
1、通过html的标签里面v-if对超出范围的进行隐藏

<div v-for="(item,index) in courselist" v-if="index < 6" :key='index'></div>
2、通过sclie截取数组的长度控制循环的次数

<div v-for="(item,index) in courselist.slice(0,6)" :key="index"></div>
```

## 32.Cannot read property '$createElement' of undefined

```javascript
Cannot read property '$createElement' of undefined
一般是vue router报出错误,一般是 在写 component 时 写成了 components
```

## 33.@click.native

用于 `vue 2.x版本`

```javascript
@click.native 是vue在绑定点击事件时用到的指令,因为要给组件加上点击事件,所以要加上.native
 子组件内部处理click事件然后向外发送click事件：$emit("click".fn)
```

## 34.如何用 css 绘制一个点或者圆形

```css
i {
  width: 6px;
  height: 6px;
  border-radius: 100%;
  display: inline-block;
  margin-top: -2px;
  vertical-align: middle;
  background: red;
  margin-right: 8px;
}
```

## 35.判断一个字符串是不是日期

```javascript
const date = '2020-01-01'
if (isNaN(date) && !isNaN(Date.parse(date))) {
  console.log('yes')
}
```
