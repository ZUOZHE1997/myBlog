---
title : 原型与原型链
date : 2023-7-11
---


## 原型

JavaScript 是一门面向对象的编程语言,每一个 Object 都会有一个`[[Prototype]]` 属性,这个属性值不是`null`就是对另一个对象的引用,这个对象就叫`原型`,这个属性一般是隐藏的私有属性,要设置他的一种方式就是用`__proto__`这个特殊名字

`____proto__`这个属性没有被赋值的话他是默认指向它的构造函数的原型对象(`prototype`),而几乎所有 JavaScript 中的对象都是位于原型链顶端的 `Object` 的实例,此时的`Object`也有一个`__proto__`属性,他是一个`null`,此时就是原型链的终点了

```javascript
const person = { walk: true }

const tom = { jumps: true }

tom.__proto__ = person

console.log(tom.walk)

// true
```

这里将 tom 的`__proto__`属性指向了 person,此时 person 就是 tom 的原型,又或是 tom 的原型是继承自 person 的

这里再补充一个点:`.prototype`属性是只有构造函数才有的属性,不要记混了

## 原型链

一个原型对象的原型不是`null`的话,那么串起来的链表结构就是**原型链**,其实一个原项链也可以理解成一个由对象组成的有限对象的链表来实现继承和共享属性,上文代码就是原型链来实现继承的

先来看一个最简单的原型链的例子:

```javascript
const person = {
  walk: true,
}

console.log(person.__proto__ === Object.prototype) // true

console.log(Object.__proto__) // null
```

那这个原型链就是如图所示:

![简单的原型链](/深入学习JavaScript/简单的原型链1.png)

```javascript
const a = {
  x: 10,
  add: function (y) {
    return this.x + y
  },
}

const b = {
  x: 100,
  __proto__: a,
}

const c = {
  x: 1000,
  __proto__: a,
}

console.log(b.add(1)) // 101
console.log(c.add(1)) // 1001
```

`b`和`c`都能使用`a`定义的`add`方法,这就是由原项链来实现的,如果在当前对象中没有找到该方法的定义,就会沿着遍历原型链去查找,直到找到第一个,如果原型链上也没有,就会返回`undefined`

## 构造函数

构造函数(`constructor`)时一类特殊的函数,主要用来初始化对象,他总是与`new`关键字一起使用,他在创建对象的过程中还会做一件事情,就是为新对象设置`prototype`(原型对象),而这个原型对象是存在于`ConstructorFunction.prototype`中的

```javascript
function Person(name) {
  this.name = name
  this.age = 10
  this.print = function () {
    console.log(`name:${this.name},age:${this.age}`)
  }
}

const tom = new Person('tom')

tom.print() // name:tom,age:10

console.log(tom.__proto__ === Person.prototype) // true
console.log(tom.constructor === Person) // true
console.log(tom.__proto__ === Person.prototype) // true
```

联系上下文我们就会得到一下结果

![简单的原型链2](/深入学习JavaScript/简单的原型链2.png)

## new 之后干了什么

new 之后操作可以简单高阔为

1. 创建一个空的对象
2. 然后将空对象的 `__proto__ `指向构造函数的原型
3. 改变 this 的指向,指向空对象
4. 对构造函数的返回值做判断，然后返回对应的值

代码实现

```javascript
function factory() {
  // 创建一个空对象
  var obj = new Object()

  // 获取构造函数
  const Constructor = [].shift.call(arguments)

  // 将这个空对象的__proto__指向构造函数的原型
  Object.setPrototypeOf(obj, Constructor.prototype)

  // 将 this 指向空对象
  var res = Constructor.apply(obj, arguments)

  return res instanceof Object ? res : obj
}

// 验证

function Person(name) {
  this.name = name
  this.age = 10
  this.print = function () {
    console.log(`name:${this.name},age:${this.age}`)
  }
}

const tom = factory(Person, 'tom')

tom.print() // name:tom,age:10
```
