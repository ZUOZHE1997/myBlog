## 函数声明与函数表达式

在创建函数的时候有两种方式,一种是**函数声明**,另一种是**函数表达式**,ECMA规定了一点,函数声明必须要带着 **标识符**(函数名),函数表达式则可以忽略掉标识符.

```javascript
// 函数声明 : 

function name(params) {
    ....
    return someValue
}

// 函数表达式 :

const fun = function(params){
    ....
    return someValue
}

```

由此可见,如果 _函数如果是作为一个赋值表达式的一部分的话,他就是一个函数表达式,但是如果被包含在一个函数体内或程序内的话他就是一个函数声明_


``` javascript
function func(){} // 函数声明 ,因为他放在了程序文件中

const func = function func(){} // 函数表达式,因为他作为赋值表达式的一部分

new function func() // 函数表达式,他作为new表达式的一部分

(function(){
    function func(){} // 函数声明，因为它是函数体的一部分
  })();
```

而且他们在执行过程中也有着细微差别,当程序在执行时的时候,函数声明会提前声明(会在程序开始运行前被解析,也就是我们常见的**函数提升**,函数在JavaScript中是一等公民)

```javascript
console.log(func())

function func(){
    return "hello"
}
 // hello
```
这里的`func`函数会被提升到当前程序顶部提前声明,所以会打印`hello`

还有一种比较特别的例子是函数语句出现在`块级作用域中的时候`

```javascript

if(true){
    function func(){ // 这里其实被当作的函数表达式来执行的
        return 1
    }
} else {
    function func(){
        return 2
    }
}

func()
// 1
```
执行过程中其实是把他当作函数表达式来执行的(_**当在块级作用域中的时候,允许函数声明,行为类似于var声明一个变量,而且函数会提升到当前跨级作用域开头**_),只不过是将`a`这个同名变量提升到了顶部,然后在执行的时候给这个同名变量进行赋值:


```javascript
var func = undefined

if(true){
    func = function func(){
        return 1
        }
} else {
    func = function func(){
        return 2
        }   
}

func()
// 1
```

再来看这个:


```javascript
{
 a = 123
 function a () {}
}
console.log(a)

// 123

```
执行过程类似这样:

```javascript

var a = undefined // 先声明一个同名变量 a
{
    function a () {} // 提升函数到当前块级作用域开头,给同名变量赋值
    a = 123   // 重新给 a 赋值
}

console.log(a) // 打印 123

```

扯一嘴 `var`声明变量,`var a = "helloworld"`会被引擎解析成 

```javascript
var a = undefined 
a= "helloworld"
```


## 其他注意点

### 命名函数表达式

像是 `const a = function func(){}` 这样的函数表达式其实叫做**命名函数表达式**,这里的`func`这个函数名只会在函数内部才会有效

```javascript
const a = function func(){
    console.log(func) // 打印函数  func(){console.log(func)}
}

console.log(func) // Uncaught ReferenceError: func is not defined

```



