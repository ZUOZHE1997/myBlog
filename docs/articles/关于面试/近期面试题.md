## 1.比较两个数组的是否相同


```javascript
// 比较两个数组的是否相同
function equar(a, b) {
  // 判断数组的长度
  if (a.length !== b.length) {
    return false
  } else {
    // 循环遍历数组的值进行比较
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false
      }
    }
    return true
  }
}
```



## 2.关于 flex 一些注意点

关于 flex 属性,第一个数值是 flex-grow。赋值为正数的话是让元素增加所占空间。第二个数值是 flex-shrink — 正数可以让它缩小所占空间，但是只有在 flex 元素总和超出主轴才会生效。最后一个数值是 flex-basis；flex 元素是在这个基准值的基础上缩放的。

1. flex: initial 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。
2. flex: auto 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。
3. flex: none 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。




## 3.CSS 权重问题

关于 css 权重问题,

- 行内样式权重大于外联和内联,
- 内联样式如果写在了外联样式的前面,那么外联样式会取代内联样式



```html
<head>
  <style>
    .content {
      width: 100px;
    }
  </style>
  <link rel="stylesheet" href="css/styles.css" />
</head>
<!-- 外联大于内联 -->
```



1. 常用选择器权重优先级：!important > id > class > tag
2. !important 可以提升样式优先级，但不建议使用。如果!important 被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被应用上!important。 例如：background: blue !important;
3. 如果两条样式都使用!important，则权重值高的优先级更高
4. 在 css 样式表中，同一个 CSS 样式你写了两次，后面的会覆盖前面的
5. 样式指向同一元素，权重规则生效，权重大的被应用
6. 样式指向同一元素，权重规则生效，权重相同时，就近原则生效，后面定义的被应用
7. 样式不指向同一元素时，权重规则失效，就近原则生效，离目标元素最近的样式被应用




## 4.闭包理解

我将永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。


## 5. call,apply,bind 应用


- 可以将\伪数组转换成数组(例如通过 document.getElementsByTagName 获取的元素、含有 length 属性的对象)
- 数组拼接,添加
- 判断变量类型(判断 object 或者是 array)
- `function isArray(obj) { return Object.prototype.toString.call(obj) === '[object Array]'; }`
- 用 call 和 apply 做继承




## 6.html 新增


- 增加了 header，footer，nav, aside, section 等语义 化标签
- 在表单方面，为了增强表单，为 input 增加了 color, emial, data, range 等类型
- 在存储方面，提供了 sessionStorage，localStorage,和离线存储，通过这些存储方式方便数 据在客户端的存储和获取
- 在多媒体方面规定了音频和视频元素 audio 和 vedio，另外还 有地理定位，canvas 画布，拖放，多线程编程的 web worker 和 websocket 协议。



## 8. tcp 三次握手的原理和过程，tcp 与 udp 有什么区别


1. 发送端发送一个带有 SYN 标志的数据包给对方，接收端收到后，回传一个带有 SYN/ACK 标志的数据包表示传达确认信息，发送端再回传一个带有 ACK 标志的数据包，代表“握手”结束。
2. 
   - TCP 是面向连接的，UPD 是无连接的，即发送数据前不需要先建立连接；
   - TCP 提供可靠的服务，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达，UDP 尽最大努力交付，即不保证可靠交付。并且因为 tcp 可靠，面向连接，不会丢失数据因此适合大数据量的交换；
   - TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流，UDP 是面向报文的，UDP 没有拥塞控制，因此，网络出现拥塞不会使原主机的发送速率降低，因此会出现丢包，对实时的应用很有用，比如 IP 电话和视频会议等




## 9. http 和 https 有什么区别，加密方式是什么，传输原理是什么

区别:http 是超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准，用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 而对于 https，他是以安全为目标的 http 通道，是 http 的安全版，在 http 中加入了 ssl 层，https 的安全基础是 ssl。


## 10. 防抖和节流有什么用，一般的使用场景，原理是什么

```javascript
//多次点击只执行最后一次 --- 节流
function throttle (fn) {
    let timer = null
    return function () {
        if (timer) return
        timer = setTimeout(() => {
            fn.call(this)
            timer = null
        }, 1000)
    }
}

//一段时间后执行函数,再次点击重新计时 -- 防抖

function debounce (fn) {
    let timer = null
    return function () {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.call(this)
        }, 500)
    }
}
```



## 4. 手写判断一个字符串是不是回文字符串，如果能使用 js 中的方法，你会使用哪一个方法


```javascript
const a = "abcvbbvcba"

function check (str) {
    if (!(str || str.length > 0)) return false
    const arr = str.split(0, str.length)
    let start = 0, end = str.length
    while (start > end) {
        if (arr[start] !== arr[end]) return false
        start++, end--
    }
    return true
}

console.log(check(a))



function check2 (str) {
    if (!(str || str.length > 0)) return false
    const str2 = str.split('').reverse().join('');
    return str2 === str
}

console.log(check2(a))
```



## 5. 跨域是什么？怎么解决跨域？



## 6. CSS 实现垂直居中



## 7. transform 中的 translateY 属性



## 8. 闭包如果放在一个对象中，也可以避免被标记回收，为啥用那么绕来实现闭包。



## 9. 闭包除了直接返回一个函数，是有什么其他的逻辑呢？



## 10. 用原型来实现两个构造函数的继承（super 类、和 son 子类，son 来继承 super 的属性和方法）



## 11. 构造函数里有 this 嘛？this 指向哪里？this 里有 prototype 吗？



## 12. 继承还有哪一些方式？



## 13. 工厂函数继承介绍一下？



## 14. ES6 更简单来实现继承？



## 16. class 中的 super 如何指定你的父类？



## 17. var 为什么可以重复声明？



## 18. if 内外可以声明同一个 let 变量吗？



## 19. 一个普通函数加 async 会有什么变化？



## 20. 如果这个普通函数返回就是 promise，加 async 还有什么变化呢？



## 21. crsf 如何拿到 cookie 呢？（A、B 网站是不同域限制的）



## 22. 如果拿到 http 请求头的 cookie 呢？