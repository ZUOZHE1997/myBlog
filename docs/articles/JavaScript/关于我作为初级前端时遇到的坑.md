### 1.vuerouter Uncaught (in promise)

这个是在用vue-router进行跳转时,重复点击了元素两次,控制台会报错,据翻看大佬的解释，vue-router ≥3.0版本回调形式以及改成promise api的形式了，返回的是一个promise，如果没有捕获到错误，控制台始终会出现如图的警告，针对于路由跳转相同的地址，目前的解决方案: 

```javascript
this.$router.push('/location').catch(err => { console.log(err) })
```


> 大佬说是在main.js文件下加入如下代码：


```javascript
import Router from 'vue-router'
const originalPush = Router.prototype.push
Router.prototype.push = function push(location) {
 return originalPush.call(this, location).catch(err => err)
}
```

 结果：加入后亲测有效，确实不再提示这个错误了

### 2.css设置多行溢出
```css
单行溢出
overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;
```
 
```css
多行溢出
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;
```


## 3.刷新的方法:


```
//用的是reload方法
window.location.reload()
//这种方法不好的方式是会刷新空白,用户体验很不好
```


## 4.css鼠标🈲用


```css
pointer-events: none;
cursor: default;
opacity: 1;//设置透明度
```


## 5,get方法与post方法区别


#### http
超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。
#### http方法：
HEAD: 与 GET 相同，但只返回 HTTP 报头，不返回文档主体 PUT: 上传指定的 URI 表示 DELETE: 删除指定资源 OPTIONS: 返回服务器支持的 HTTP 方法 CONNECT: 把请求连接转换到透明的 TCP/IP 通道 POST: 向指定的资源提交要被处理的数据
```
// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
复制代码
```
GET: 从指定的资源请求数据
#### GET和POST的区别

1. GET 请求可被缓存
1. GET 请求保留在浏览器历史记录中
1. GET 请求可被收藏为书签
1. GET 请求不应在处理敏感数据时使用
1. GET 请求有长度限制(2048字符),IE和Safari浏览器限制2k;Opera限制4k;Firefox，Chrome限制8k
1. GET 请求只应当用于取回数据



1. POST 请求不会被缓存
1. POST 请求不会保留在浏览器历史记录中
1. POST 不能被收藏为书签
1. POST 请求对数据长度没有要求



## 6.js求平面两点之间的距离


```javascript
// 数据可以以数组方式存储，也可以是对象方式
let a = {x:'6', y:10},
        b = {x: 8, y: 20};
    function distant(a,b){
        let dx = Number(a.x) - Number(b.x)
        let dy = Number(a.y) - Number(b.y)
        return Math.pow(dx*dx + dy*dy, .5)
    }
```


## 7.css禁止用户选择👆


```css
body{
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
}
```
## 8.for in 与for of 方法


```javascript
let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2)
    function find(arr) {
        for (let num of arr) {
            console.log(num)
        }
    }
    find(arr)
//for of中的num是完整的arr数组中的值
let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2)
    function find(arr) {
        for (let num in arr) {
            console.log(num)
        }
    }
    find(arr)
//但是for in 中的num相当于下标,只有输出arr[num]才能获得数组中的值

```


## 9.数组去重


```javascript
//indexOf()方法   
let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2)
    function find(arr) {
        let res = []
        for (let num of arr) {
            if (res.indexOf(num) === -1) {
                res.push(num)
            }
        }
        return res
    }
    console.log(find(arr))\
    //1,2,3,5,6
```

## 10.如何提高首频加载速度
> 1.js外联文件放到body底部，css外联文件放到head内
> 2.http静态资源尽量用多个子域名
> 3.服务器端提供html和http静态资源时最好开启gzip
> 4.在js,css,img等资源响应的http headers里设置expires,last-modified
> 5.尽量减少http requests的数量
> 6.js/css/html/img资源压缩
> 7.使用css spirtes，可以减少img请求次数
> 8.大图使用lazyload懒加载
> 9.避免404，减少外联js
> 10.减少cookie大小可以提高获得响应的时间
> 11.减少dom elements的数量
> 12.使用异步脚本，动态创建脚本



## 11.简述一下你对HTML语义化的理解
用正确的标签做正确的事情。 html语义化让页面的内容结构化，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 

## 12.请描述一下 cookies，sessionStorage 和 localStorage 的区别
cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage  数据在当前浏览器窗口关闭后自动删除。 cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 

## 13.css overflow属性
overflow 属性规定当内容溢出元素框时发生的事情。
> 这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。

值:

| visible | 默认值。内容不会被修剪，会呈现在元素框之外。             |
| ------- | -------------------------------------------------------- |
| hidden  | 内容会被修剪，并且其余内容是不可见的。                   |
| scroll  | 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 |
| auto    | 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 |
| inherit | 规定应该从父元素继承 overflow 属性的值。                 |

## 让overflow:scroll平滑滚动


```javascript
-webkit-overflow-scrolling: touch;
```


## 14.position中的relative和absolute的定位原点问题
absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值

## 15.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？

- png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.
- 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 
- IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb{ background-color:red;/_所有识别_/ background-color:#00deff\9; /_IE6、7、8识别_/ +background-color:#a200ff;/_IE6、7识别_/ _background-color:#1e0bd1;/_IE6识别_/ } 
- IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。 
- IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 
- 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 
- Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 
- 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}



## 16.css优化,提高性能

关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；

## 17.让页面里的字体变清晰，变细用CSS怎么做
```javascript
-webkit-font-smoothing: antialiased;
```


## 18.This对象的理解
> this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；


 

## 19.什么是window对象? 什么是document对象
> window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。



## 20.什么是闭包（closure），为什么要用它？
> 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部


 

## 21.如何判断一个对象谁否属于某个类


```javascript
if(a instanceof Person){
   alert('yes');
}
//instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

// 判断对象类型最好的方式
// 对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。
//而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。
Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(Symbol()); //[object Symbol]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用

```


## 22.new一个对象的过程
1、创建一个空对象，并且 **this** 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 **this** 引用的对象中。 3、新创建的对象由 **this** 所引用，并且最后隐式的返回 **this** 。 

## 23.在Vue中的遍历方法v-for控制循环次数的方法

 **1.截取循环的数据**     v-for="(item,index) in domainList.slice(0, 2)"     用这样的方法可以截取循环的数据长度，从而控制循环的次数 **2.通过v-if来控制**      v-for="(item,index) in domainList" v-if="index<3"     在标签下紧跟v-if来进行控制，这里是用索引来进行控制的，所以循环的时候记得把index这个参数加到v-for循环中。

## 24.箭头函数
对于箭头函数，`this` 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。 

## 25.获取接口数据的定义的数组


```javascript
 list: {
        course: {
          public_assesses: [],
          course_contents: [],
          public_collects: [],
          introduction: ''
        }
      },
```
在获取数据时，由于接口返回的数据嵌套过多，导致页面渲染报错，在定义数组保存接口数据时，可以定义好要接受的数据的“模版”，或者说把要使用的数据拿出来单独赋值

## 26.vue-router跳转页面时传参成功但是页面没有刷新


```javascript
watch: {
    '$route' (to, from) {
      this.$router.go(0)
    }
  },
```
用watch监听router属性是否有变化，然后决定是否重新刷新页面

## 27.设置默认显示的子路由


```javascript
path: '/',
  component: () =>
      import('@/views/home_page/index'),
  name: 'home_page',
  redirect: 'index_cntent',//用redirect指出默认显示的子路由 
  children: [{
    path: '/about_menu',
    component: () =>
          import('@/views/menu/about_menu'),
    name: 'about_menu'
  },
  {
    path: '/dervice_menu',
    component: () =>
          import('@/views/menu/dervice_menu'),
    name: 'dervice_menu'
  },
  {
    path: '/product_menu',
    component: () =>
          import('@/views/menu/product_menu'),
    name: 'product_menu'
  },
  {
    path: '/service_menu',
    component: () =>
          import('@/views/menu/service_menu'),
    name: 'service_menu'
  },
  {
    path: '/index_cntent',
    component: () =>
          import('@/views/menu/content'),
    name: 'index_cntent'
  }
  ]
},
```


## 28关于vue warn的警告解决
一般出现 vue warn 的时候一般是vue数据渲染出错，绑定的某个值可能赋值出错，像是给了undefined，或者是原本是图片地址却给了个字符串之类错误，往往导致这方面的错误的时候，提示里一般没有相关文件具体到哪一行那个语法出错，但是会提示了是那个文件，去文件里面逐一排查就好 

## 29.最简单的方式实现前端下载功能（window.location）
用`window.locatio.href=“xxxx?”+（其他字段）+'&(其他字段)'`的方式可以实现打开新的窗口下载文件，前提是后端给返回文件的下载地址，默认打开地址的话像是图片会直接预览 

## 30.textarea禁止拖动,固定宽高
        
```
resize: none;
```
## 31.控制v-for循环的次数


```javascript
1、通过html的标签里面v-if对超出范围的进行隐藏

<div v-for="(item,index) in courselist" v-if="index < 6" :key='index'></div>
2、通过sclie截取数组的长度控制循环的次数

<div v-for="(item,index) in courselist.slice(0,6)" :key="index"></div>
```


## 32.Cannot read property '$createElement' of undefined


```javascript
Cannot read property '$createElement' of undefined
一般是vue router报出错误,一般是 在写 component 时 写成了 components  
```


## 33.@click.native

用于 `vue 2.x版本`
```javascript
@click.native 是vue在绑定点击事件时用到的指令,因为要给组件加上点击事件,所以要加上.native
 子组件内部处理click事件然后向外发送click事件：$emit("click".fn)
```


## 34.如何用css绘制一个点或者圆形
```css
i {
    width: 6px;
    height: 6px;
    border-radius: 100%;
    display: inline-block;
    margin-top: -2px;
    vertical-align: middle;
    background: red;
    margin-right: 8px;
}
```
## 35.判断一个字符串是不是日期
```javascript
const date = '2020-01-01'
if (isNaN(date) && !isNaN(Date.parse(date))) {
console.log("yes")
         }
```