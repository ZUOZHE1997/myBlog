常规函数

```javascript
function funcName(params) {
  return params + 2
}
funcName(2)
// 4
```

箭头函数:

```javascript
var funcName = (params) => params + 2
funcName(2)
// 4
```

如果没有参数，那么可以进一步简化：

```javascript
;() => {
  statements
}
```

如果只有一个参数，可以省略括号:

```javascript
;(parameters) => {
  statements
}
```

如果返回值仅仅只有一个表达式(expression), 还可以省略大括号：

```javascript
parameters => expression
// 等价于:
function (parameters){
  return expression;
}
```

<a name="RrdrU"></a>

### 1.不会绑定 htis

同时,箭头函数不会绑定`this`。 或者说箭头函数不会改变`this`本来的绑定

```javascript
function Counter() {
  this.num = 0
}
var a = new Counter()
```

因为使用了关键字`new`构造，Count()函数中的`this`绑定到一个新的对象，并且赋值给`a`。通过`console.log`打印`a.num`，会输出 0。

```javascript
console.log(a.num)
// 0
```

<a name="mXhQA"></a>

### 2.没有 arguments 对象

箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：

```
function constant() {
    return () => arguments[0]
}
var result = constant(1);
console.log(result()); // 1
```

那如果我们就是要访问箭头函数的参数呢？<br />你可以通过命名参数或者 rest 参数的形式访问参数:

```
let nums = (...nums) => nums;
```

<a name="Tfmp7"></a>

### 3.不能通过 new 关键字调用

```javascript
var Foo = () => {}
var foo = new Foo() // TypeError: Foo is not a constructor
```

原因是:

> javascript 函数有两个内部方法：[[Call]] 和 [[Construct]]。
> 当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。
> 当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。
> 箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错

<a name="fu9cI"></a>

### 4.没有原型

由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。

```javascript
var Foo = () => {}
console.log(Foo.prototype) // undefined
```
