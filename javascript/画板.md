---
title: 画板
date: 2021-02-05
tags: 前端
categories:
  - notes
  - 2021
excerpt: 画板工具
---




一时兴起做了个画板,原先想着前端用 React 写,正好学一下 React ,结果写了没两天就老是碰壁 🤣,也折腾了好久的 Redux 和 react-router-dom,后来暂时改用 Vue 了,不过也是用的 Vue3,等过年回家好好折腾一下 React 然后用 React 重构一下

# 知识点整理

## Vue3

Vue3 的最重要的一个更新之一就是 CompositionAPI,这个和以前 Options API 还是有一些不一样的,最明显的变化就是没有了 this 的上下文,而且代码的组织更加好,逻辑关注点都在一起,总之就是写起来更爽了

<!-- 在写的时候各种 -->

在 CompositionAPI 中加了一个 Setup 函数,所有的方法,生命周期都放在 Setup 函数里,而且那些 API 都是在使用时引入就可以了,Setup 函数的执行时间是在 beforeCreate 、created 之前执行

```vue
<template>
  <div></div>
  <!-- 允许多标签  -->

  <div>
    helloworld
    <child-components ref="child"></child-components>
  </div>
</template>

<script>
import { computed, ref, onMounted } from 'vue'

export default {
  name: 'test',
  setup(props, context) {
    console.log(props) // 父组件传过来的props,不要解构,会失去响应性
    const { attrs, slots, emit } = context // 上下文
    // attrs Attribute 属性
    // slots 插槽
    // emit 方法,相当于this.$emit
    const data1 = 1 // 不是 一个响应性的对象
    const data2 = ref('1') // 用ref创建的是一个响应性的
    const child = ref('child') // 访问子组件 相当于 this.$refs["child"] ,前提是先注册
    console.log(data1, data2.value) // 用ref创建的对象访问时需要访问它的value属性
    const a = computed(() => {
      return 1
    })
    onMounted(() => {
      console.log('我是生命周期函数')
    })
    return {
      a,
      data1,
      data2,
    }
  },
}
</script>
```

具体的信息可以去看一下官网的文档,那里更详细,我也只是写个大概哈哈 😂

## Vuex 4

安装: ` npm install vuex@next --save`

CompositionAPI 中的使用:

```JavaScript
    import { useStore } from "vuex"; //引入

    const store = useStore();
    const data = store.state.name; // 访问 state中的值
    store.dispatch("send", data); // 调用actions

```

## vue-router 4

安装 `npm install vue-router@4`

CompositionAPI 中的使用:

```JavaScript

import { useRouter, useRoute } from 'vue-router' // 引入

export default {
  setup() {
    const router = useRouter() // 相当于this.$router
    const route = useRoute() // 相当于 this.$route

    function pushWithQuery(query) {
      router.push({
        name: 'search',
        query: {
          ...route.query,
        },
      })
    }
  },
}
```

路由钩子 beforeEach

```JavaScript

const router = createRouter({ ... })

router.beforeEach((to, from) => { // next成为了一个可选的参数
// 当时返回一个 undefined或true的时候导航都是被验证成功,会继续调用下个路由钩子

if(!isLogin)  return "/login"
// 当返回值是一个 地址的时候,直接重定向到地址

//   return false
// 取消当前导航,如果浏览器URL被更改（由用户手动或通过后退按钮更改），它将被重置为该from路由的URL 。

})
```

```
又要拖一会,最近事太多了😭
```