<a name="GGPNs"></a>

## 计算属性

我们可以在对象字面量中使用方括号。这叫做**计算属性**。<br />例如：

```javascript
let fruit = prompt('Which fruit to buy?', 'apple')
let bag = {
  [fruit]: 5, // 属性名从 fruit 变量中计算
}
alert(bag.apple) // 5 如果 fruit="apple"
```

计算属性的含义很简单：`[fruit]`  含义是这个值从  `fruit`  变量中获取。<br />所以，如果一个人输入  `"apple"`，`bag`  将是  `{apple: 5}`。<br />本质上，这跟下面的语法相同：

```javascript
let fruit = prompt('Which fruit to buy?', 'apple')
let bag = {}
// 从 fruit 变量中获取值
bag[fruit] = 5
```

…但是看起来好多了。<br />我们在方括号中可以用更复杂的表达式：

```javascript
let fruit = 'apple'
let bag = {
  [fruit + 'Computers']: 5, // bag.appleComputers = 5
}
```

方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。<br />大部分时间里，当属性名是已知且简单的时候，用点方法。如果有一些复杂的操作，那么就用方括号。<br />**保留字段可以用作属性名**<br />变量名不能用保留字段，像：“for”, “let”, “return” 等。<br />对于对象的属性，没有这些限制，都可以的：

```javascript
let obj = {
  for: 1,
  let: 2,
  return: 3,
}
alert(obj.for + obj.let + obj.return) // 6
```

基本上，什么都可以，只有一个特殊的：`"__proto__"`  因为历史原因要特别对待。比如，我们不能把它设置为非对象的值：

```javascript
let obj = {}
obj.__proto__ = 5
alert(obj.__proto__) // [object Object]，这样不行
```

我们从代码中可以看出来，把它赋值成  `5`  被忽略了。<br />如果我们蓄意去存储随机的键值对或者允许一个访问者去指定键，那可能就会产生很多 bug 并且使对象变得危险。<br />比如，访问者可能选择  `__proto__`  作为键，这个赋值的逻辑就失败了（像上面那样）。
<a name="HpDGu"></a>

## 存在值检查

对象的一个显著的特点就是可以访问任何属性，如果这个属性名没有值也不会有错误。访问一个不存在的属性会返回  `undefined`。它提供一种普遍的方法去检查属性是否存在 —— 获得值来与 undefined 比较：

```javascript
let user = {}
alert(user.noSuchProperty === undefined) // true 意思是没有这个属性
```

同样的,也可以用  **in **来检查属性是否存在

```javascript
let user = { name: 'John', age: 30 }
alert('age' in user) // true，user.age 存在
alert('blabla' in user) // false，user.blabla 不存在。
```

注意  `in`  的左边必须是**属性名**。通常是一个字符串，如果不用字符串，那就是一个字符串变量。

```
let user = { age: 30 };
let key = "age";
alert( key in user ); // true，获取键的名字和检查这个键的属性
```

**Using “in” 属性中存储  `undefined`**<br />通常，严格比较  `"=== undefined"`  就够用，但是也有一些特殊情况，`"in"`  就可以胜任。<br />那就是属性存在，但是存储  `undefined`：

```
let obj = {
  test: undefined
};
alert( obj.test ); //  它是 undefined，所以难道它不存在吗？
alert( "test" in obj ); // true，属性存在！
```

在上面的代码中，属性  `obj.test`  事实上是存在的，所以  `in`  操作符可以。<br />这种情况很少发生，因为 undefined 通常情况下是不会被赋值到对象的，我们经常会用  `null`  来表示未知的或者空的值。

<a name="D8w1Y"></a>

## for in 循环

为了使用对象所有的属性，就可以利用  `for..in`  循环。

```javascript
let user = {
  name: 'John',
  age: 30,
  isAdmin: true,
}
for (let key in user) {
  // keys
  alert(key) // name, age, isAdmin
  // 属性键的值
  alert(user[key]) // John, 30, true
}
```

注意，所有的 “for” 都允许我们在循环中定义变量，像  `let key`  这样。<br />同样，我们可以用其他属性名来代替  `key`。例如  `"for(let prop in obj)"`  也很常用。

<a name="yiDMj"></a>

## 引用复制

<br />**变量存储的不是对象本身，而是对象的“内存地址”，是对象的引用。**<br />\***\*当对象被复制的时候 – 引用被复制了一份, 对象并没有被复制。**<br />如果我们将对象想象成是一个抽屉，那么变量就是一把钥匙，拷贝对象是复制了钥匙，但是并没有复制抽屉本身。<br />例如：

```
let user = { name: "John" };
let admin = user; // 复制引用
```

现在我们有了两个变量，但是都指向同一个对象,也就**相当于 C 语言中的指针**<br />\*\*
<a name="AIgdJ"></a>

## 复制和合并

可以用 `object.assign`方法<br />语法是：

```javascript
Object.assign(dest,[ src1, src2, src3...])
```

- 参数  `dest`  和  `src1, ..., srcN`（可以有很多个）是对象。
- 这个方法复制了  `src1, ..., srcN`  的所有对象到  `dest`。换句话说，从第二个参数开始，所有对象的属性都复制给了第一个参数对象，然后返回  `dest`。

```javascript
let person = {
  name: 'john',
  age: '18',
}
let personGender = {
  gender: 'man',
}
let personLike = {
  like: 'basketball',
}
let allPerson = {
  name: 'ann',
}
console.log(allPerson.name) //ann
//如果接收的对象（allPerson）已经有了同样属性名的属性，前面的会被覆盖
Object.assign(allPerson, person, personGender, personLike)
console.log(allPerson) // age: "18" gender: "man" like: "basketball" name: "john"
```

<br />我们可以用  `Object.assign`  来代理简单的复制方法：

```javascript
let user = {
  name: 'John',
  age: 30,
}
let clone = Object.assign({}, user)
```

它复制了  `user`  对象所有的属性给了一个空对象，然后返回拷贝后的对象。事实上，这跟循环赋值一样，但是更短。<br />直到现在，我们是假设所有的  `user`  属性都是原始值，但是如果对象属性指向对象呢？<br />像这样：

```javascript
let user = {
  name: 'John',
  sizes: {
    height: 182,
    width: 50,
  },
}
alert(user.sizes.height) // 182
```

现在，并不能拷贝  `clone.sizes = user.sizes`，因为  `user.sizes`  是一个对象，它按引用拷贝。所以  `clone`  和  `user`  共享了一个对象。<br />像这样：<br />

```javascript
let user = {
  name: 'John',
  sizes: {
    height: 182,
    width: 50,
  },
}
let clone = Object.assign({}, user)
alert(user.sizes === clone.sizes) // true，同一个对象
// user 和 clone 共享 sizes 对象
user.sizes.width++ // 在这里改变一个属性的值
alert(clone.sizes.width) // 51，在这里查看属性的值
```

为了解决上面的的问题，我们在复制的时候应该检查  `user[key]`  的每一个值，如果是一个对象，我们再复制一遍这个对象，这叫做**深拷贝。**<br />

<a name="KWsYl"></a>

## 深拷贝与浅拷贝

浅拷贝是指**修改 B 对象的属性和方法会影响到 A 对象的属性和方法,相当于直接赋值**<br />深拷贝是指**修改 B 对象的属性和方法不会影响到 A 对象的属性和方法,相当于赋值时判断一下**<br />

```javascript
let user = {
  name: 'john',
  age: 19,
  gender: 'man',
  other: {
    work: 'teacher',
    hobby: 'football',
  },
}
let person = {}
//实现深拷贝
function clone(obj1, obj2) {
  for (let key in obj1) {
    //开始循环
    console.log(obj1[key])
    var item = obj1[key]
    //将第一个值赋值给item
    //然后判断是否是object
    if (item instanceof Object) {
      //如果是的话新建一个object类型,相当于开辟一块新的内存空间
      let newObj = new Object()
      //开始递归,把是object类型的值赋值给新的内存空间
      clone(item, newObj)
      //把新的内存空间指向obj2,如果obj1里面的object类型的里面还有一个object,也将赋值给新的之前递归的新开辟的内存空间
      obj2[key] = newObj
    } else {
      obj2[key] = obj1[key]
    }
  }
}
clone(user, person)
user.age = 20 //这里更改user.age的值不会影响到person里面的值的变化
console.log(person)
```

<a name="WLvYr"></a>

## 垃圾回收

垃圾回收的基本算法被称为 “mark-and-sweep”。<br />定期执行以下“垃圾回收”步骤：

- 垃圾收集器找到所有的根，并“标记”（记住）它们。
- 然后它遍历并"标记"来自它们的所有参考。
- 然后它遍历到标记的对象并标记**他们的**引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
- …一直这样，直到有未访问的引用（从根访问到）。
- 没有被标记的所有对象都被删除。

例如，让我们的对象结构如下所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/514813/1572501417369-984979f2-153f-41bb-b13c-552083a7f6b3.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=578&size=14419&status=done&style=none&width=412)<br />我们可以在右侧清楚地看到一个『无法到达的岛屿』。现在我们来看看"mark-and-sweep"垃圾收集器如何处理它。<br />第一步标记所有的根：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/514813/1572501432215-7d959345-b578-476d-80cc-5a58076e2194.png#align=left&display=inline&height=246&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=569&size=16045&status=done&style=none&width=454)<br />然后他们的引用被标记了：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/514813/1572501449736-7035aa07-8c3a-46e7-afcb-6c286e6b05b7.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=566&size=16998&status=done&style=none&width=455)<br />…如果还有引用的话，继续标记：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/514813/1572501462976-dffde5fc-2471-4c03-abce-b6a38fcc4a3c.png#align=left&display=inline&height=231&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=569&size=17371&status=done&style=none&width=444)<br />现在，这个过程中没有被遍历过的对象将会被删除。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/514813/1572501478210-5b716b86-f915-47bc-9c12-dcb1f616daa0.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=573&size=19407&status=done&style=none&width=525)<br />这是垃圾收集如何工作的概念。<br />JavaScript 引擎做了许多优化，使其运行速度更快，并且不会影响代码运行。<br />一些优化点：

- **分代收集** —— 对象被分成两组：『新的』和『旧的』。许多对象出现，完成他们的工作并快速释放，他们可以很快被清理。那些长期存活下来的对象会变得『老旧』，而且检查的次数也会减少。
- **增量收集** —— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分逐一处理。这需要他们之间额外的标记来追踪变化，但是会有许多微小的延迟而不是大的延迟。
- **闲时收集** —— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

<br />

<a name="Sy8ft"></a>

## 对象方法与 this

```javascript
let user = {
  name: 'John',
  age: 30,
}
user.sayHi = function () {
  alert('Hello!')
}
user.sayHi() // Hello!
```

这里使用函数表达式创建了函数，并将其指定给对象的  `user.sayHi`  属性。<br />随后调用它。user 现在可以说话了！<br />**作为对象属性的函数称之为方法。**<br />那么，现在  `user`  对象有了一个  `sayHi`  方法。<br />
<br />在使用 vue 的过程中,我们也就是用了**方法**<br />在很多时候，对象方法需要访问对象中的存储的信息来完成其工作。<br />举个例子，`user.sayHi()`  中的代码可能需要用到  `user`  的 name 属性。<br />**为了访问该对象，方法中可以使用  `this`  关键字。**<br />`this`  的值就是在点之前的这个对象，即调用该方法的对象。<br />例如:

```javascript
let user = {
  name: 'John',
  age: 30,
  sayHi() {
    alert(this.name)
  },
}
user.sayHi() // John
```

<br />
<br />实际上，我们可以在没有任何对象的情况下调用函数：
```javascript
function sayHi() {
  alert(this);
}
sayHi(); // undefined
```
在这种情况下，严格模式下的 `this` 值为 `undefined`。如果尝试访问 `this.name`，将会出现错误。<br />在非严格模式（没有使用 `use strict`）的情况下，`this` 将会是**全局对象**（浏览器中的 `window)`。`"use strict"` 可以修复这个历史行为。<br />请注意，通常在没有对象的情况下使用 `this` 的函数调用是不常见的，会（导致）编程错误。如果函数中有 `this`，那么通常意味着它是在对象上下文环境中被调用的。
<a name="ZCmxX"></a>
### 内部：引用类型

<br />『复杂』的方法调用可能会失去  `this`，比如：

```javascript
let user = {
  name: 'John',
  hi() {
    alert(this.name)
  },
  bye() {
    alert('Bye')
  },
}
user.hi() // John (the simple call works)
// 现在我们要判断 name 属性，来决定调用 user.hi 或是 user.bye。
;(user.name == 'John' ? user.hi : user.bye)() // Error!
```

最后一行中有一个三元运算符，它要判断是  `user.hi`  或  `user.bye`。在这种情况下，结果会是  `user.hi`。<br />该方法立即被括号  `()`  调用。但它无效。<br />你可以看到该调用导致了错误，因为调用中的  `"this"`  为  `undefined`。<br />这样是正确的（对象点方法）：

```javascript
user.hi()
```

这样没有效果（对方法求值）：

```javascript
;(user.name == 'John' ? user.hi : user.bye)() // 错误！
```

原因是什么？如果我们想了解为什么会这样，那么我们要深入理解  `obj.method()`  调用的原理。<br />仔细看，我们可能注意到  `obj.method()`  语句中有两个操作符。

1. 首先，点  `'.'`  取得这个  `obj.method`  属性。
1. 其后的括号  `()`  调用它。

那么，`this`  是如何从第一部分传递到第二部分的呢？<br />如果把这些操作分离开，那么  `this`  肯定会丢失：

```javascript
let user = {
  name: 'John',
  hi() {
    alert(this.name)
  },
}
// 将赋值与方法调用拆分为两行
let hi = user.hi
hi() // 错误，因为 this 未定义
```

这里  `hi = user.hi`  把函数赋值给变量，其后的最后一行是完全独立的，所以它没有  `this`。<br />**为了让  `user.hi()`  有效，JavaScript 用一个技巧 —— 这个  `'.'`  点返回的不是一个函数，而是一种特殊的\*\***引用类型\***\*的值。**<br />引用类型是一种『规范中有的类型』。我们不能明确地指定它，但是可以在语言内部使用。<br />引用类型的值是三点的结合  `(base, name, strict)`，如下：

- `base`  是对象。
- `name`  是属性。
- 当  `use strict`  生效，`strict`  为真。

`user.hi`  属性访问的值不是函数，而是引用类型的值。在严格模式下，`user.hi`  是：

```javascript
// 引用类型值
user, 'hi', true
```

`()`  被引用类型调用时，将接收关于该对象及其方法的所有信息，并且设定正确的  `this`  值（这里等于  `user`）。<br />`hi = user.hi`  赋值等其他的操作，将引用类型作为一个整体丢弃，只获取  `user.hi`（一个函数）的值进行传递。因此，进一步操作『失去』了  `this`（值）。<br />所以如果直接使用点  `obj.method()`  或方括号语法  `obj[method]()`（它们在这里并无差别）调用函数，那么作为结果，`this`  值会以正确的方式进行传递。
<a name="LJpNE"></a>

### 箭头函数没有自己的 “this”

箭头函数有些特别：它们没有自己的  `this`。如果我们在这样的函数中引用  `this`，`this`  值取决于外部『正常的』函数。<br />举个例子，这里的  `arrow()`  使用的  `this`  来自外部的  `user.sayHi()`  方法：

```javascript
let user = {
  firstName: 'Ilya',
  sayHi() {
    let arrow = () => alert(this.firstName)
    arrow()
  },
}
user.sayHi() // Ilya
```

<br />

<a name="XwR91"></a>

### 题目:

这段代码的结果是什么？

```javascript
let user = {
  name: 'John',
  go: function () {
    alert(this.name)
  },
}(user.go)()
```

<br />答案:

```javascript
let user = {
  name: 'John',
  go: function () {
    alert(this.name)
  },
}(user.go)() // error!
```

大多数浏览器中的错误信息并不能说明出现了什么问题。<br />**出现此错误是因为在  `user = {...}`  之后遗漏了一个分号。**<br />JavaScript 不会在括号  `(user.go)()`  前自动插入分号，所以解析的代码如下：

```javascript
let user = { go:... }(user.go)()
```

那么，我们可以看到这样一个连接的表达式，在语法构成上，把对象  `{ go: ... }`  作为一个方法调用，并且传递的参数为  `(user.go)`。并且让  `let user`在同一行赋值，因此  `user`  没被定义（之前）就会出现错误<br />如果我们插入该分号，一切都会正常：

```javascript
let user = {
  name: 'John',
  go: function () {
    alert(this.name)
  },
}
user.go() // John
```

要注意的是  `(user.go)`  内的括号没有什么意义。通常用它们来设置操作的顺序，但在这里点  `.`  总是会先执行，所以并没有什么影响。分号是唯一重要的。
