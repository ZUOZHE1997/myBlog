剩余扩展运算符是 ES6 中一个比较重要的点，常用三个点来表示（...）,后面跟着一个含有 iterator 接口的数据结构
<a name="nmn6v"></a>

### 扩展运算符

以数组为例,使用扩展运算符使得可以"展开"这个数组，可以这么理解，数组是存放元素集合的一个容器，而使用扩展运算符可以将这个容器拆开，这样就只剩下元素集合，你可以把这些元素集合放到另外一个数组里面<br />![](https://cdn.nlark.com/yuque/0/2019/webp/514813/1574142730921-2de90b79-b5d3-494d-9020-4c4c7e09f078.webp#align=left&display=inline&height=129&originHeight=129&originWidth=426&size=0&status=done&width=426)<br />扩展运算符可以代替 ES3 中数组原型的 concat 方法<br />![](https://cdn.nlark.com/yuque/0/2019/webp/514813/1574142730922-241883a5-5ae9-4c56-8a49-d55e3d271e7c.webp#align=left&display=inline&height=201&originHeight=201&originWidth=468&size=0&status=done&width=468)<br />这里将 arr1,arr2 通过扩展运算符展开,随后将这些元素放到一个新的数组中,相对于 concat 方法语义化更强
<a name="mMlu8"></a>

### 剩余运算符

剩余运算符最重要的一个特点就是替代了以前的 arguments<br />访问函数的 arguments 对象是一个很昂贵的操作，以前的 arguments.callee,arguments.caller 都被废止了，建议在支持 ES6 语法的环境下不要在使用 arguments 对象，使用剩余运算符替代（箭头函数没有 arguments，必须使用剩余运算符才能访问参数集合）<br />![](https://cdn.nlark.com/yuque/0/2019/webp/514813/1574142730923-bfb90150-847b-40bc-8b23-048cee663776.webp#align=left&display=inline&height=381&originHeight=381&originWidth=501&size=0&status=done&width=501)<br />剩余运算符可以和数组的解构赋值一起使用，但是必须放在**最后一个**，因为剩余运算符的原理其实是利用了数组的迭代器，它会消耗 3 个点后面的数组的所有迭代器，读取所有迭代器生成对象的 value 属性，剩运算符后不能在有解构赋值，因为剩余运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错<br />![](https://cdn.nlark.com/yuque/0/2019/webp/514813/1574142730930-bd7cd309-e6d6-4f10-9610-03f5c3971294.webp#align=left&display=inline&height=201&originHeight=201&originWidth=805&size=0&status=done&width=805)<br />这里 first 会消耗右边数组的一个迭代器，...arr 会消耗剩余所有的迭代器，而第二个例子...arr 直接消耗了所有迭代器，导致 last 没有迭代器可供消耗了，所以会报错，因为这是毫无意义的操作<br />**剩余运算符和扩展运算符的区别就是，剩余运算符会收集这些集合，放到右边的数组中，扩展运算符是将右边的数组拆分成元素的集合，它们是相反的**
<a name="d6MkX"></a>

### 在对象中使用扩展运算符

这个是 ES9 的语法，ES9 中支持在对象中使用扩展运算符，之前说过数组的扩展运算符原理是消耗所有迭代器，但对象中并没有迭代器，我个人认为可能是实现原理不同，但是仍可以理解为将键值对从对象中拆开，它可以放到另外一个普通对象中<br />![](https://cdn.nlark.com/yuque/0/2019/webp/514813/1574142730919-a4453b65-49df-47b6-a270-1fc557f96ff1.webp#align=left&display=inline&height=291&originHeight=291&originWidth=274&size=0&status=done&width=274)<br />其实它和另外一个 ES6 新增的 API 相似，即 Object.assign，它们都可以合并对象，但是还是有一些不同 Object.assign 会触发目标对象的 setter 函数，而对象扩展运算符不会，这个我们放到后面讨论
<a name="Q0Fy6"></a>

### 建议

使用扩展运算符可以快速的将类数组转为一个真正的数组<br />![](https://cdn.nlark.com/yuque/0/2019/webp/514813/1574142730954-a07dbbd6-89f1-4600-89ff-2be16ddd0017.webp#align=left&display=inline&height=183&originHeight=183&originWidth=625&size=0&status=done&width=625)<br />合并多个数组<br />![](https://cdn.nlark.com/yuque/0/2019/webp/514813/1574142730923-688e10c1-d69a-4efe-83d1-9f5068819d8c.webp#align=left&display=inline&height=165&originHeight=165&originWidth=426&size=0&status=done&width=426)
