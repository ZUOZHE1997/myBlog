<a name="PK4n7"></a>
# 1.**HTML加载过程**
1. 加载HTML-DOM结构
1. CSS和JS
1. 图片和多媒体
1. 加载事件触发
<a name="rAAIT"></a>
# 2.用set方法给数组去重
```javascript
const arr = [1,2,3]
const obj = [{name:"frank"},{age:12}]
const arr2 = [arr,23,1,1,2,4,23,obj,63,arr,arr,obj]
const set = new Set(arr2)
console.log(   JSON.stringify([...set]))
//数组去重
//[[1,2,3],23,1,2,4,[{"name":"frank"},{"age":12}],63]
```
<a name="article-title"></a>
# 3.export deault


```javascript
export 用于导出函数或者变量,将他们暴露在外面
可以导出:
export const str="helloworld",
export const str2="iamdog",
export const str3="hahaha"
格式也可以是export default{
str,str2,str3}
在应用时需要用打括号{}引入
```
<a name="gwDOO"></a>
# 4.相对路径与绝对路径
相对路径:<br />./代表他的所在目录,<br />../代表父级目录<br />../../代表 父级目录 的 父级目录<br />/代表根目录<br />绝对路径<br />比如:http://www.baidu.com/image/img1.jpg
<a name="zdsca"></a>
# 5.callback回调函数
callback回调函数本质上是一个函数调用另一个函数<br />在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。<br />因此callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。<br />简单的例子:<br />

```javascript
function fun1(callback){
const num =12;
  callback(num)
}
fun1((num)=>{
console.log(num)
})
//打印结果是   22
```
<a name="eiseK"></a>
# 6.什么是localStorage
对浏览器来说，使用 Web Storage 存储键值对比存储 Cookie 方式更直观，而且容量更大，它包含两种：localStorage 和 sessionStorage

1. sessionStorage（临时存储） ：为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载
1. localStorage（长期存储） ：与 sessionStorage 一样，但是浏览器关闭后，数据依然会一直存在

所以上次使用cookie的时候就遇到了一个坑,设置后马上访问session会获取不到,蛋疼,还需要刷新一下,原因是:<br />当我们首次访问设置Cookie的页面时，服务器会把设置的Cookie值通过响应头发送过来，告诉浏览器将cookie存储的本地相应文件夹中（注意:第一次访问时本地还没有存储Cookie,所以此时获取不到值）;<br />当第二次访问(或在进行cookie设置后,过期前所有的访问)时，请求头信息你中都会把Cookie值携带。(百度到的,暂时还没理解透彻,先搬过来).
<a name="KRTYZ"></a>
## 保存


```javascript
//对象
 
const info = { name: 'hou', age: 24, id: '001' };
 
//字符串
 
const str="haha";
 
  
 
localStorage.setItem('hou', JSON.stringify(info));
 
localStorage.setItem('zheng', str);
```
<a name="0HtEC"></a>
## 获取


```javascript
var data1 = JSON.parse(localStorage.getItem('hou'));
 
var data2 = localStorage.getItem('zheng');
　　
```
<a name="aSkNX"></a>
## 删除


```javascript
//删除某个
 
localStorage.removeItem('hou');
//删除所有
localStorage.clear();
```
<a name="aYQto"></a>
## 监听


```javascript
Storage 发生变化（增加、更新、删除）时的 触发，同一个页面发生的改变不会触发，只会监听同一域名下其他页面改变 Storage
window.addEventListener('storage', function (e) {
　　console.log('key', e.key); console.log('oldValue', e.oldValue);
　　console.log('newValue', e.newValue); console.log('url', e.url);
})
```


<a name="BwVfP"></a>
## vue中的使用
根据我的需求来的一个默认记住上次选择的,很简单<br />添加数据的时候,下次添加默认记住我上次的选择<br />所以,在添加或者提交的时候存储值即可,<br />localStorage.setItem('projectId',me.workhourData.projectId+","+me.workhourData.projectManager);<br /> <br />在打开新建页面的时候获取一下就好了,只需要判断非空就行<br />

```javascript
//记住上次选中的审核人
            if(localStorage.length>0){
                var mydata = localStorage.getItem('projectId');
                if(mydata!=null){
                    var arr3=mydata.split(",");
                    if(arr3[0]==me.workhourData.projectId){
                        me.workhourData.projectManager=arr3[1];
                    }
                }
            }
```


<a name="Gg8L7"></a>
## 注意点
localStorage有效期是永久的。一般的浏览器能存储的是5MB左右。sessionStorage api与localStorage相同。<br />sessionStorage默认的有效期是浏览器的会话时间（也就是说标签页关闭后就消失了）。<br />localStorage作用域是协议、主机名、端口。（理论上，不人为的删除，一直存在设备中）<br />sessionStorage作用域是窗口、协议、主机名、端口。<br />知道了这些知识点后，你的问题就很好解决了。<br />localStorage是window上的。所以不需要写this.localStorage，vue中如果写this，是指vue实例。会报错<br />

<a name="mwdGa"></a>
# 7.数组的几个常用方法
<a name="HuCP8"></a>
## 1. includs()方法
```javascript
const arr = [1,2,3,4,5,6]
arr.includes(2)
//true
arr.includes(10)
//false
```
includes()方法可以简化if...else...语句
```javascript
//原先的表达式
if(a===1||a===3||a===7||a===10){
...
}
//可以简化成
if([1,3,7,10].includes(a)){
...
}
```
<a name="cCfkN"></a>
##  2. some函数


```javascript
some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。

some() 方法会依次执行数组的每个元素：

如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
如果没有满足条件的元素，则返回false。
注意： some() 不会对空数组进行检测。

注意： some() 不会改变原始数组。

const arr = [12,13,14,19,17]
function checkNum = data = >{
return data>=18
}
function check = ()=>{
console.log(arr.some(checkNum))
}
// true
```
<a name="2pEHC"></a>
## 3. concat()方法
```javascript
var arr = new Array(1, 2, 3, 4, 5)
var arr2 = new Array(6, 7, 8, 9, 0)

concat()	//连接两个或更多的数组，并返回结果。
console.log(arr.concat(arr2))		//[1,2,3,4,5,6,7,8,9,0]
//连接多个数组  arr.concat(arr2,arr3,...)
//也可以连接元素 arr.concat(1,2) 	//[1,2,3,4,5,1,2]
```
<a name="kagUF"></a>
## 4. join()方法
```javascript
var arr = new Array(1, 2, 3, 4, 5)
var arr2 = new Array(6, 7, 8, 9, 0)

join()	//把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
console.log(arr.join())		//1,2,3,4,5
var i = arr.join()
console.log(typeof i)		//string
//也可以指定连接符
console.log(arr.join('-'))		//1-2-3-4-5
```
<a name="PgR4X"></a>
## 5. pop()方法
```javascript
var arr = new Array(1, 2, 3, 4, 5)
var arr2 = new Array(6, 7, 8, 9, 0)

pop()	//删除并返回数组的最后一个元素
console.log(arr.pop())  //5
console.log(arr)  //[1,2,3,4]
```
<a name="DufRI"></a>
## 6. push()方法
```javascript
var arr = new Array(1, 2, 3, 4, 5)
var arr2 = new Array(6, 7, 8, 9, 0)

push()	//向数组的末尾添加一个或更多元素，并返回新的长度。
console.log(arr.push(11))  //6
console.log(arr)  //[1,2,3,4,5,11]
```
<a name="V0ETq"></a>
## 7. reverse()方法
```javascript
var arr = new Array(1, 2, 3, 4, 5)
var arr2 = new Array(6, 7, 8, 9, 0)

reverse()	//颠倒数组中元素的顺序。
console.log(arr.reverse())  //[5,4,3,2,1]
```
<a name="le3ls"></a>
## 8. shift()方法
```javascript
var arr = new Array(1, 2, 3, 4, 5)
var arr2 = new Array(6, 7, 8, 9, 0)

shift()	//删除并返回数组的第一个元素
console.log(arr.shift())  //[2,3,4,5]
//如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。
//请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。
```
<a name="EqAFa"></a>
## 9. slice()方法
```javascript
var arr = new Array(1, 2, 3, 4, 5)
var arr2 = new Array(6, 7, 8, 9, 0)

slice()	//从某个已有的数组返回选定的元素
console.log(arr.slice(2))  //[3,4,5]
//参数:arrayObject.slice(start,end)
//start:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。
//也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。
//end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。
//如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。
```
<a name="zEcA8"></a>
## 10.其他方法
```javascript
sort()	//对数组的元素进行排序
splice()	//删除元素，并向数组添加新元素。
toSource()	//返回该对象的源代码。
toString()	//把数组转换为字符串，并返回结果。
toLocaleString()	//把数组转换为本地数组，并返回结果。
unshift()	//向数组的开头添加一个或更多元素，并返回新的长度。
valueOf()	//返回数组对象的原始值
```
<a name="Selwy"></a>
# 8.遍历
<a name="S5zfj"></a>
## 1.for in 
for in循环键值<br />

```javascript
const arr = [1,2,3]
for(let i in arr ){
console.log(arr[i])
}
//1 2 3

```
缺点是:

- 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。如果你使用字符串的 index 去参与某些运算（"2" + 1 == "21"），运算结果可能会不符合预期。
- for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
- 某些情况下，for...in循环会以任意顺序遍历键名。
- 总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。



<a name="xKtLi"></a>
## 2.for of 
这个是循环对值<br />[掘金](https://juejin.im/post/5e82978af265da47ee3f4a16)一篇文章 说的很好,for of 与forEach相比,优点还是不少的,

- 可以就地结构
- 可以迭代(数组,字符串,set和map对象等)
- 循环JavaScript普通对象等
- 不同于forEach方法，它可以与break、continue和return配合使用。
- 提供了遍历所有数据结构的统一操作接口。


<br />缺点是不太适合太长的数组对象等的循环
<a name="6Abzk"></a>
## 3.forEach()方法(ES5新增,低版本IE不支持)
forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。<br />注意: forEach() 对于空数组是不会执行回调函数的。
```javascript
array.forEach(function(currentValue, index, arr), thisValue)
注意:currentValue是当前的值
index是当前下标
arr是当前数组

const arr = [1,2,3,5,7]
arr.forEach((value,index,arr)=>{
console.log(value,index)
})
//1,0
//2,1
//3,2
//4,7
```

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

